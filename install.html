<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Install - Wispux Linux</title>
		<link rel="icon" href="/favicon.ico" type="image/x-icon">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<header>
			<h1>Wispux</h1>
			<a href="/wispux/index.html">Home</a>
                        <a href="/wispux/install.html">Installation Guide</a>
                        <a href="/wispux/about.html">About</a>
		</header>
		<main>
			<b>1. Preparations and Requirements</b>
			<p class="instructions">
			This is a simple guide to get your system up and running,
			you are free to customize Wispux and your installation process however you'd like.
			To begin, you must be booted into a host disk that is different
			from your target disk. The most ideal way to achieve this is to flash
			a live linux iso to a usb, cd, or other bootable device. Void and Alpine's live images
			are recommended. Download
			one of these images or another minimal live iso and flash it to a usb or cd
			that doesn't have any important data saved to it. WARNING: FLASHING A MEDIA DEVICE
			WILL WIPE ALL ITS DATA! Below is an example of flashing a void iso to the device at /dev/sdb.
			</p>
			<code>
			dd if=void.iso of=/dev/sdb bs=4M
			</code>
			<p class="instructions">
			This installation process requires an internet connection as well as
			certain packages to be installed on your host system.
			Keep in mind that if you are building a multilib system, you will also be required to have
			certain 32 bit libraries installed.
			Please make sure that at least the following are installed:
			</p>
			<pre><code>curl
git
openssl
tar
gzip
xz
zstd
unzip
gcc
make
bison
flex
python
texinfo
patch
</code></pre>
			<p class="instructions">
			If you are installing using an Alpine image, you will find the following necessary to install as well.
			<pre><code>build-base
bash
file
sed
gawk
mount
umount
b2sum
e2fsprogs
</code></pre>
			<b>2. Partitioning and Formatting</b>
			<p class="instructions">
			WARNING: MAKE SURE YOU FORMAT AND PARTITION THE CORRECT DISK AS ALL DATA WILL BE WIPED!
			Depending on your system and personal expectations, you will be expected to partition and format your target disk differently.
			On a BIOS system, it is advised to use MBR as your partition scheme, while on a newer UEFI system, it is more
			common to use GPT. UEFI systems will also expect an EFI partition which should be formatted as FAT32 for best
			compatibility. In the end, you are expected to at least have a root partition, optionally a swap partition, and
			an EFI partition depending on your setup. You may also divide your root into multiple partitions dedicated to
			locations such as /var, /etc, /home, etc., though this is more advanced. Below are basic reference tables for BIOS
			and UEFI.
			</p>
			<b>BIOS with MBR</b>
			<table>
				<tr>
					<th>Mount point</th>
					<th>Partition type</th>
					<th>Recommended size</th>
				</tr>
				<tr>
					<th>swap</th>
					<th>swap</th>
					<th>4GB+</th>
				</tr>
				<tr>
					<th>/</th>
					<th>Linux</th>
					<th>The remainder of the device</th>
				</tr>
			</table>
			<b>UEFI with GPT</b>
			<table>
				<tr>
					<th>Mount point</th>
					<th>Partition type</th>
					<th>Recommended size</th>
				</tr>
				<tr>
					<th>/boot/efi</th>
					<th>EFI</th>
					<th>512MB</th>
				</tr>
				<tr>
					<th>swap</th>
					<th>swap</th>
					<th>4GB+</th>
				</tr>
				<tr>
					<th>/</th>
					<th>Linux x86-64 root</th>
					<th>The remainder of the device</th>
				</tr>
			</table>
			<p class="instructions">
			You can partition /dev/sda with fdisk:
			</p>
			<code>fdisk /dev/sda</code>
			<p class="instructions">
			After partitioning to your needs, you must format the partitions so that they can be used.
			Below is an example for a UEFI system.
			</p>
			<pre><code>mkfs.vfat -F 32 /dev/sda1
mkswap          /dev/sda2
mkfs.ext4       /dev/sda3</code></pre>
			<b>3. Mounting Filesystems</b>
			<p class="instructions">
			Below is an example of how you can mount the partitions according to the UEFI reference table above.
			</p>
			<pre><code>mount --mkdir /dev/sda3 /mnt/wispux
mount --mkdir /dev/sda1 /mnt/wispux/boot/efi
swapon /dev/sda2</code></pre>
			<b>4. The Wispux Bootstrap</b>
			<p class="instructions">
			Wispux uses a shell script to automate most of it's install process.
			If everything is set up correctly, the only stage expected to prompt the user for manual intervention is the final stage, 33.
			Don't be intimidated by this large number though, as said, if your host system is set up correctly, has the required packages, 
			and you've followed the previous steps correctly, you shouldn't have anything to worry about.
			</p>
			<p class="instructions">
			There are two versions of the bootstrap, multilib and nomultilib, the difference being whether you can run 32 bit on your 64 bit system or not.
			Unless you are on a 64 bit system where you expect to run 32 bit binaries or libraries, you should choose nomultilib.
			An example of of system needing multilib would be one expected to run Wine or Proton.
			If you choose nomultilib, you will not be able to switch to multilib without reinstalling from scratch.
			On the other hand, building a nomultilib toolchain on a multilib system is rather simple.
			Now download your choice of script and make it executable:
			</p>
			<pre><code>curl -LO https://catnipsta.github.io/wispux/wispux-bootstrap-nomultilib.sh
chmod +x wispux-bootstrap-nomultilib.sh</code></pre>
			<p class="instructions">
			If you are feeling paranoid, you may also download the sha256 sum of the bootstrap and
			verify it as shown below.
			</p>
			<pre><code>curl -LO https://catnipsta.github.io/wispux/wispux-bootstrap-nomultilib-sha256
cat wispux-bootstrap-nomultilib-sha256
sha256sum wispux-bootstrap-nomultilib.sh</code></pre>
			<p class="instructions">
			The bootstrap contains a list of packages that will be installed to your new system.
			One of these packages is vi, a text editor. If you are not comfortable with vi, please
			edit the bootstrap and replace vi with one you are comfortable with. Please also ensure that this text editor
			is also installed on your host system for reasons that will be made clear later.
			</p>
			<p class="instructions">
			Setting MAKEFLAGS enables your system to start multiple compile jobs at once.
			This speeds up the process, though setting them too high will result in crashes.
			You should set your job limit (the second number) to your total RAM in gigabytes divided
			by 2. You can check your total RAM by running:
			</p>
			<code>free -h</code>
			<p class="instructions">
			On a system with 8 gigabytes of RAM, you would set your MAKEFLAGS like so:
			</p>
			<code>
			export MAKEFLAGS="-j$(nproc) -l4"
			</code>
			<p class="instructions">
			Now run the bootstrap, passing your mount point as a parameter.
			</p>
			<code>
			./wispux-boostrap-nomultilib.sh /mnt/wispux
			</code>
			<p class="instructions">
			STAGE 2 will ask you for your preferred Linux kernel, glibc, and GCC version.
			If you can't decide, just press enter to select the default versions.
			After that, the bootstrap should have no problem running until STAGE 33.
			</p>
			<b>5. STAGE 33</b>
			<p class="instructions">
			If you have ever performed or studied LFS, you can think of STAGE 33 like Chapter 8.
			Unlike LFS, STAGE 33 is mostly automated. I say mostly automated because it uses
			Arch's PKGBUILDs for installing packages. Many PKGBUILDs are patched by the bootstrap
			and while many packages will install without any manual intervention, some PKGBUILDs are going to require modification.
			Each time a packge fails to compile, it will almost definitely be because of the PKGBUILD.
			What better time to learn the drag package manager than now?
			</p>
			<p class="instructions">
			You can edit bc's PKGBUILD by running the command:
			</p>
			<code>snoop bc</code>
			<p class="instructions">
			Some PKGBUILDs will have complex configure options that aren't supported yet on your minimal system. To fix these,
			remove or modify these options. Others will fail because of tests. Remember that not all tests 
			are expected to pass since this is in a chroot environment. To disable tests, just remove the whole check
			function from a PKGBUILD. Arch's PKGBUILDs also contain lots of install commands in the package functions which don't
			always work, especially after you've modified a PKGBUILD. If you come across lines in the package function attempting
			to install or modify files which don't exist, remove them.
			</p>
			<b>6. Chroot</b>
			<p class="instructions">
			Enter your new system.
			</p>
			<pre><code>chroot /mnt/wispux /bin/bash
source /etc/profile
export PS1="(chroot) ${PS1}"</code></pre>
			<p class="instructions">
			If you don't plan on using the en_US.UTF-8 locale, or wish you generate others, you may generate and
			optionally set your LANG variable to something other than en_US.UTF-8 like so:
			</p>
			<pre><code>localedef -i ru_RU -f UTF-8 ru_RU.UTF-8
echo "LANG=ru_RU.UTF-8" > /etc/locale.conf</code></pre>
			<p class="instructions">
			Set your hostname in the /etc/hostname file.
			</p>
			<code>echo "wispux-desktop" > /etc/hostname</code>
			<p class="instructions">
			Create a file called /etc/hosts and follow a scheme similar to the one shown below.
			</p>
			<pre><code>127.0.0.1    localhost wispux-desktop
::1          localhost</pre></code>
			<p class="instructions">
			To set your timezone, tzdata needs to be installed.
			</p>
			<code>smoke tzdata</code>
			<p class="instructions">
			Set your time zone by creating a symlink at /etc/localtime pointing to your timezone.
			Replace the ??? in the command below with your corresponding time zone. For example: US/Pacific.
			</p>
			<pre><code>ln -sf /usr/share/zoneinfo/??? /etc/localtime</code></pre>
			<b>7. Compiling the Kernel</b>
			<p class="instructions">
			To configure your kernel, you can either manually edit /usr/src/linux-x.x.x/.config or you can use a tool like
			menuconfig or nconfig. You can set the variable EXTRAVERSION found in the Makefile to "-wispux" to generate a
			kernel with the ending "-wispux". 
			Below is an example of how you can configure, compile, and install the Linux kernel 6.12.44.
			</p>
			<pre><code>cd /usr/src/linux-6.12.44
make mrproper
make nconfig
make
make modules_install
make install
mv /boot/vmlinuz /boot/vmlinuz-6.12.44-wispux
mv /boot/System.map /boot/System.map-6.12.44</code></pre>
			<p class="instructions">
			Remember that you may also need to install linux-firmware depending on the drivers you need.
			</p>
			<b>8. User and password setup</b>
			<p class="instructions">
			Setting up users and passwords is rather simple compared to the rest of this guide.
			To set passwords, use the passwd command, passing the user as a parameter.
			If you don't pass a user as a parameter, it will default to root.
			Setting a passwod for root isn't required, but it is helpful.
			</p>
			<p class="instructions">
			You can add a user named "wispux-user" and create their home directory like this:
			</p>
			<code>
			useradd -m wispux-user
			</code>
			<p class="instructions">
			You can also add wispux-user to groups using the usermod command.
			</p>
			<code>
			usermod -aG wheel wispux-user
			</code>
			<p class="instructions">
			Set wispux-user's password.
			</p>
			<code>
			passwd wispux-user
			</code>
			</br>
			<b>9. Bootloader Setup</b>
			<p class="instructions">
			There are quite a few many bootloaders, but the most common and featured one is GRUB.
			You can install GRUB using the drag package manager.
			</p>
			<code>
			smoke grub
			</code>
			<p class="instructions">
			If you are running a UEFI system, you will most likely want to additionally install efibootmgr. You may also
			need to mount your efivars for GRUB and efibootmgr to detect that you are on an EFI system. You can do this
			as shown below.
			</p>
			<code>
			mount -t efivarfs efivarfs /sys/firmware/efi/efivars
			</code>
			<p class="instructions">
			You can install GRUB for 32 and 64 bit BIOS systems assuming that your target is /dev/sda with
			the commands shown below.
			</p>
			<pre><code>grub-install --target=i386-pc /dev/sda
grub-mkconfig /boot/grub/grub.cfg</code></pre>
			<p class="instructions">
			You can install GRUB for 64 bit UEFI systems assuming that your efi
			directory is /boot/efi with the commands shown below.
			</p>
			<pre><code>grub-install --target=x86_64-efi --efi-directory=/boot/efi
grub-mkconfig /boot/grub/grub.cfg</code></pre>
			<b>10. Reboot</b>
			<p class="instructions">
			Some people may choose at this point to install and set up certain packages such as sudo.
			It would also be recommended at this point to review and edit the /sbin/init script so that you know what
			commands are going to run on startup.
			</p>
			<p class="instructions">
			You may now exit the chroot, unmount your newly created system, and reboot.
			</p>
			<pre><code>exit
umount -R /mnt/wispux
reboot</code></pre>
		</main>
		<footer>
			<p>2025 Catnipsta - Nikolai Klover - GPLv3</p>
                        <p>LinuxÂ® is the registered trademark of Linus Torvalds in the U.S. and other countries.</p>
		</footer>
	</body>
</html>
